\chapter{FastFlow}
\label{chap:fastflow}
FastFlow is the result of a joint effort of the Parallel Programming Model Group of the University of Pisa and the Parallel Computing Research Group of the University of Turin. FastFlow is a C++ structured parallel programming framework, that leverages a streaming data-flow approach and originally targeted cache-coherent shared-memory architectures \cite{fastflow}. It was recently extended with a distributed-memory runtime in order to allow developers to build and deploy FastFlow applications over distributed environments. The FastFlow library was built with a layered design by keeping efficiency in the base mechanisms to maintain efficiency across the whole framework \cite{fastflow-highlevel}. Each of the implemented layers provides abstractions at different levels in order to help both the application and the RTS developer. The top level abstractions provide classical parallel patterns targeting the application developer, the lowest layers instead expose abstractions for the RTS programmer, by providing a reduced set of \texttt{Building Blocks} (BBs from now on), that can be used to efficiently implement most of the existing parallel applications \cite{fastflow-highlevel}.

\section{Building Blocks}
\texttt{Building Block}s are the core elements of FastFlow programming, since they are used as the basic abstraction layer to properly build FastFlow streaming parallel patterns. \texttt{BB}s come in two flavor, \textit{sequential} and \textit{parallel} and they both rely over Single-Producer Single-Consumer (SPSC) lock-free queues to share memory and allow efficient communication.\newline

The implemented building-blocks are the \textit{pipeline}, \textit{farm} and the \textit{all-to-all}. The \textit{pipeline} building block has a double usage, in fact it can be used to connect building blocks and to build pipeline parallelism. The \textit{farm} is used to express functional replication which is controlled both in input and output by \texttt{Emitter} and \texttt{Collector} entities which can be specialized in order to implement different dispatching/gathering policies. Finally, the \textit{all-to-all} building block offers the possibility to implement the shuffle communication pattern and to remove bottlenecks coming from centralized entities in the \textit{farm} building block.

The main characteristic of \texttt{building blocks} is their composition-oriented nature, which allows the programmer to assemble them in a LEGO-style fashion in order to build complex parallel applications. This reflects the style of the structured parallel programming methodology and enables a more organized way to build parallel applications.

\section{FastFlow distributed runtime}
Since the last version of FastFlow, a distributed runtime has been added which allows for FastFlow applications to be organized and deployed over distributed computing nodes via a set of wrappers class and renewed \texttt{BB} components. The introduced mechanisms for the distributed runtime allows the programmer to easily and efficiently divide and deploy an existing application into \textit{distributed groups}, as well as creating a new application directly for the distributed environment retaining the same LEGO-style approach for parallel application on shared-memory systems.\newline

The distributed extension for the FastFlow library is provided by modification at the \texttt{BB} level in order to provide the easy porting of existing shared-memory FastFlow application into the distributed environment without dealing with the burden of handling distributed communications; provide a set of mechanisms to implement higher-level ready-to-use distributed patterns.
\subsection{Transition to distributed-memory}
The transition from shared-memory to distributed-memory required the creation of new concepts, as the one of \textit{distributed groups}, as well as new abstractions, as the classes for serialization and communication of the task to be sent across the network. Existing applications can be deployed in the distributed environment by retaining the semantic of the original FastFlow application. The only modifications required for an application programmer to transform a shared-memory FastFlow application into a mixed shared/distributed-memory application are related to the identification of disjoint \textit{distributed groups} via the provided API calls and the mapping of each group to an endpoint by means of a JSON configuration file.

The distributed groups (\textit{dgroups} henceforth) represent logical partitions of the original FastFlow application which are executed on remote nodes. Each one of the \textit{dgroups} is realized as a shared-memory application to fully exploit the potential of the single nodes. Moreover, the resulting \textit{dgroup} is internally plugged with specific sequential \texttt{BB}s and node wrappers to realize serialization/deserialization and communication between the deployed \textit{dgroups} by retaining the original application semantic.

