\chapter{Background on HPC communication layer}
\label{chap:background}
As described by \cite{survey-distributed}, we can consider the HPC communication layer as ``\textit{any framework, library, tool protocol or patter that eases the communication between distributed processes}'', and its only purpose is to abstract the user from the underlying infrastructure and protocols by providing a set of APIs to send and receive messages. Following this line, and by considering the distinctions made by \cite{survey-distributed}, we can consider two main paradigms:
\begin{itemize}
	\item \textbf{Remote Invocation}: allows the user to call functions from one node to the other across the network. We consider in this category both \textit{Remote Method Invocation} (RMI) and \textit{Remote Procedure Call} (RPC), with the only distinction between the two being they are used to invoke object's methods or program functions, respectively. 
	\item \textbf{Message Oriented}: also in this category we can distinguish two paradigms, \textit{Message Passing Interface} (MPI) and \textit{Message Queuing} (MQ). The former being the de-facto standard in HPC, with minimal overhead, low level minimal abstraction and no fault tolerance; the latter, instead, offers queues to store intermediate messages still not received and it offers fault tolerance. 
\end{itemize}

By following the distinction made before, we list some of the most common communication framework and transports used in HPC and BDA environments, as also reported by \cite{survey-distributed}. However, we only a brief description of each one of them, since the main aim of this chapter is to show the plethora of transports which can be found in the wild and which need to be considered when developing a communication related framework or library.

\textbf{Java RMI} -  Java RMI system \cite{javarmi} is the de-facto standard in remote communication between Java Virtual Machines, since it provides an efficient mechanism for method invocations on Java objects residing in different machines. Its communication protocol is based on TCP/IP connections and is strictly integrated with the Java environment \cite{javaRMI-toHPC++}.\newline

%TODO define other tools and frameworks before talking about Mercury
%\textbf{gRPC} - gRPC \cite{grpc} is a RPC framework
%
%\textbf{Mercury RPC} - Mercury \cite{mercury} is an asynchronous RPC framework specifically targeted at HPC systems with high-performance fabrics. It leverages an abstracted network implementation via a set of plugins which provide network implementations. The separation of concerns between the network functionalities and the abstracted API allows for this framework to be easily ported even on future systems. \newline

\textbf{MPI} - The Message Passing Interface (MPI) \cite{mpi40} is a \textit{message-passing library interface specification}, it describes requirements targeting the message passing parallel programming model by providing a set of function specification that must be implemented to provide communication functionalities between processes. The main MPI's aim is standardization of message-passing functionalities to improve scalability, portability and ease-of-use. It is the de-facto standard for communications among processes in distributed systems, and various implementation of the specification exists, like OpenMPI \cite{openMPI} and MPICH \cite{MPICH}.\newline

\textbf{ZeroMQ} - ZeroMQ \cite{zeromq} is a communication library built on top of sockets which supports in-process, inter-process, TCP and multicast transports. It allows different communication patterns, like pub-sub, request-reply fan-out and offers an asynchronous I/O model for scalable multicore applications. It was the framework used in the first versions of FastFlow's distributed runtime.\newline

%TODO aggiungere commenti riguardo al fatto che framework e tool presentati fino ad ora sono limitati per il tipo di protocolli compatibili o per il modo di effettuare le comunicazioni. Introdurre quindi Mercury come framework RPC estendibile e astratto dal protocollo e passare a capitolo successivo.